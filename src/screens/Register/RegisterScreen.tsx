import React, { useState } from "react";
import { View, Text, StatusBar, TouchableOpacity, Image, Alert, Platform, TouchableWithoutFeedback, Keyboard, ScrollView, Animated, Easing } from "react-native";
const AnimatedContainer: React.ComponentType<any> = Animated.createAnimatedComponent(View as any) as any;
import { RootView } from "../../components/layout";
import { Colors } from "../../constants/colors";
import ConfirmButton from "../../components/ConfirmButton";
import TextInputComponent from "../../components/TextInput/TextInput";
import Header from "../../components/Header";
import { styles } from "./styles";
import { useNavigation } from "@react-navigation/native";
import { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { useRegisterCustomerMutation } from "../../services";
import { 
  validateName, 
  validatePhone, 
  validateLicensePlate,
  cleanPhone,
  formatLicensePlate 
} from "../../utils/validation";

export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
};

type NavigationProp = NativeStackNavigationProp<AuthStackParamList>;

export default function RegisterScreen() {
  const navigation = useNavigation<NavigationProp>();
  const [name, setName] = useState("");
  const [phone, setPhone] = useState("");
  const [licensePlate, setLicensePlate] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [headerOffset, setHeaderOffset] = useState(0);
  const translateY = React.useRef(new Animated.Value(0)).current;

  const [registerCustomer] = useRegisterCustomerMutation();

  const handleRegister = async () => {
    // Validate name (required)
    const nameValidation = validateName(name);
    if (!nameValidation.isValid) {
      Alert.alert("L·ªói x√°c th·ª±c", nameValidation.error || "H·ªç v√† t√™n kh√¥ng h·ª£p l·ªá");
      return;
    }

    // Validate phone (required)
    const phoneValidation = validatePhone(phone);
    if (!phoneValidation.isValid) {
      Alert.alert("L·ªói x√°c th·ª±c", phoneValidation.error || "S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá");
      return;
    }

    // Validate license plate (optional but must be valid format if provided)
    const plateValidation = validateLicensePlate(licensePlate);
    if (!plateValidation.isValid) {
      Alert.alert("L·ªói x√°c th·ª±c", plateValidation.error || "Bi·ªÉn s·ªë xe kh√¥ng h·ª£p l·ªá");
      return;
    }

    setIsLoading(true);
    try {
      // Clean and format data before sending
      const cleanedPhone = cleanPhone(phone);
      const formattedPlate = licensePlate.trim() ? formatLicensePlate(licensePlate) : undefined;
      
      const requestBody: { name: string; phone: string; license_plate?: string; avatar_url?: string } = {
        name: name.trim(),
        phone: cleanedPhone,
      };

      // Only include license_plate if provided
      if (formattedPlate) {
        requestBody.license_plate = formattedPlate;
      }

      console.log('RegisterScreen: Registering with:', requestBody);
      const result = await registerCustomer(requestBody).unwrap();
      console.log('RegisterScreen: Registration result:', result);
      
      if (result.success) {
        Alert.alert(
          "ƒêƒÉng k√Ω th√†nh c√¥ng! üéâ", 
          result.message || "B·∫°n c√≥ th·ªÉ ƒëƒÉng nh·∫≠p ngay b√¢y gi·ªù",
          [
            {
              text: "OK",
              onPress: () => navigation.navigate("Login")
            }
          ]
        );
      } else {
        Alert.alert("L·ªói", "ƒêƒÉng k√Ω th·∫•t b·∫°i!");
      }
    } catch (error: any) {
      console.error('RegisterScreen: Registration error:', error);
      
      // Handle specific error cases from backend
      let errorMessage = "ƒêƒÉng k√Ω th·∫•t b·∫°i! Vui l√≤ng th·ª≠ l·∫°i.";
      
      if (error?.data?.error || error?.message) {
        const errorText = error?.data?.error || error?.message || '';
        
        // Phone already exists
        if (errorText.toLowerCase().includes('phone') && 
            (errorText.toLowerCase().includes('exist') || errorText.toLowerCase().includes('duplicate'))) {
          errorMessage = "S·ªë ƒëi·ªán tho·∫°i n√†y ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω.\nVui l√≤ng s·ª≠ d·ª•ng s·ªë ƒëi·ªán tho·∫°i kh√°c ho·∫∑c ƒëƒÉng nh·∫≠p.";
        }
        // License plate already exists
        else if (errorText.toLowerCase().includes('license') && 
                 (errorText.toLowerCase().includes('exist') || errorText.toLowerCase().includes('duplicate'))) {
          errorMessage = "Bi·ªÉn s·ªë xe n√†y ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω.\nVui l√≤ng ki·ªÉm tra l·∫°i bi·ªÉn s·ªë xe.";
        }
        // Duplicate entry (generic)
        else if (errorText.toLowerCase().includes('duplicate')) {
          errorMessage = "Th√¥ng tin n√†y ƒë√£ t·ªìn t·∫°i trong h·ªá th·ªëng.\nVui l√≤ng ki·ªÉm tra l·∫°i s·ªë ƒëi·ªán tho·∫°i ho·∫∑c bi·ªÉn s·ªë xe.";
        }
        // Missing required fields
        else if (errorText.toLowerCase().includes('required') || 
                 errorText.toLowerCase().includes('missing')) {
          errorMessage = "Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin b·∫Øt bu·ªôc (H·ªç t√™n v√† S·ªë ƒëi·ªán tho·∫°i).";
        }
        // Invalid format
        else if (errorText.toLowerCase().includes('format') || 
                 errorText.toLowerCase().includes('invalid')) {
          errorMessage = "ƒê·ªãnh d·∫°ng th√¥ng tin kh√¥ng h·ª£p l·ªá.\nVui l√≤ng ki·ªÉm tra l·∫°i s·ªë ƒëi·ªán tho·∫°i ho·∫∑c bi·ªÉn s·ªë xe.";
        }
        // Server error
        else if (errorText.toLowerCase().includes('server') || 
                 errorText.toLowerCase().includes('internal')) {
          errorMessage = "L·ªói h·ªá th·ªëng. Vui l√≤ng th·ª≠ l·∫°i sau.";
        }
        // Default: show backend error message
        else {
          errorMessage = errorText;
        }
      }
      
      Alert.alert("L·ªói ƒëƒÉng k√Ω", errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLogin = () => {
    navigation.navigate("Login");
  };

  React.useEffect(() => {
    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';
    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';

    const onShow = (e: any) => {
      const keyboardHeight = e?.endCoordinates?.height || 0;
      const duration = e?.duration || 250;
      const safeOffset = 0; // user preference (Register)
      const moveUp = Math.max(0, keyboardHeight - safeOffset);
      Animated.timing(translateY, {
        toValue: -moveUp,
        duration,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }).start();
    };

    const onHide = (e: any) => {
      const duration = e?.duration || 250;
      Animated.timing(translateY, {
        toValue: 0,
        duration,
        easing: Easing.out(Easing.cubic),
        useNativeDriver: true,
      }).start();
    };

    const subShow = Keyboard.addListener(showEvent, onShow);
    const subHide = Keyboard.addListener(hideEvent, onHide);

    return () => {
      subShow.remove();
      subHide.remove();
    };
  }, [translateY]);

  return (
    <View style={styles.container}>
      <RootView style={styles.root}>
        <StatusBar barStyle="light-content" backgroundColor={Colors.primary} />

        <View onLayout={(e) => setHeaderOffset(e.nativeEvent.layout.height)}>
          <Header title="ƒêƒÉng k√Ω" />
        </View>

        <View style={styles.body}>
          <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
            <AnimatedContainer style={{ flex: 1, transform: [{ translateY }] }}>
              <ScrollView
                contentContainerStyle={{ flexGrow: 1 }}
                keyboardShouldPersistTaps="handled"
                bounces={false}
              >
                <View style={styles.form}>
              <Text style={styles.welcomeText}>Ch√†o m·ª´ng ƒë·∫øn v·ªõi TN Auto</Text>
              <Text style={styles.subtitle}>ƒêƒÉng k√Ω t·∫°i ƒë√¢y</Text>

              <Image
                style={styles.logo}
                source={require('../../assets/logo.png')}
                resizeMode="cover"
              />

              <View style={styles.inputContainer}>
                <TextInputComponent
                  value={name}
                  onChangeText={setName}
                  placeholder="H·ªç v√† t√™n *"
                  placeholderTextColor={Colors.text.placeholder}
                />
                <TextInputComponent
                  value={phone}
                  onChangeText={setPhone}
                  placeholder="S·ªë ƒëi·ªán tho·∫°i * (VD: 0909123456)"
                  placeholderTextColor={Colors.text.placeholder}
                  keyboardType="phone-pad"
                />
                <TextInputComponent
                  value={licensePlate}
                  onChangeText={(text) => setLicensePlate(text.toUpperCase())}
                  placeholder="Bi·ªÉn s·ªë xe (VD: 29A-12345)"
                  placeholderTextColor={Colors.text.placeholder}
                />
                <Text style={styles.helperText}>* Tr∆∞·ªùng b·∫Øt bu·ªôc</Text>
              </View>

              <View style={styles.actions}>
                <ConfirmButton
                  title="ƒêƒÉng k√Ω"
                  onPress={handleRegister}
                  loading={isLoading}
                  buttonColor={Colors.button.primary}
                  textColor={Colors.text.inverted}
                />
              </View>

                  <View style={styles.signup}>
                    <Text style={styles.registerPrompt}>B·∫°n ƒë√£ c√≥ t√†i kho·∫£n?</Text>
                    <TouchableOpacity onPress={handleLogin}>
                      <Text style={styles.registerLink}>ƒêƒÉng nh·∫≠p</Text>
                    </TouchableOpacity>
                  </View>
                </View>
              </ScrollView>
            </AnimatedContainer>
          </TouchableWithoutFeedback>
        </View>
      </RootView>
    </View>
  );
}